use esp_idf_svc::hal::gpio::{Input, Level, Output, Pin, PinDriver};
use esp_idf_svc::hal::delay::Delay;
use esp_idf_svc::hal::timer::TimerDriver;

type OutputPinDriver<'a, Pin> = PinDriver<'a, Pin, Output>;
type InputPinDriver<'a, Pin> = PinDriver<'a, Pin, Input>;
const DEFAULT_STEPS_PER_MM: u32 = 1000; // todo! change later: motor_steps_per_rev * microsteps 
const SQUARE_SIZE_MM: f32 = 31.75;

pub struct MoveInstruction {
    /*
    an ordered list of squares to go to
    when to "drag", i.e. turn on the electromagnet
    the engine will generate these, becuase it knows where the pieces are and if it has to move more than the target piece around, like if a pawn needs to move for the knight needs to jump .
    all moves will be straight up/down/left/right, no diagonal.
    effectively time-based
    this is exclusively generated by the engine, not a event on the bluetooth evt bus
     */
    coords: Vec<u8>,  // 0-63 top left to bottom right
    drags: Vec<bool>, // when to turn on the magnet (actually move a piece)
}

impl MoveInstruction {
    pub fn new(coords: Vec<u8>, drags: Vec<bool>) -> Self {
        assert_eq!(coords.len(), drags.len());
        Self { coords, drags }
    }

    pub fn iter(&self) -> impl Iterator<Item = (u8, bool)> + '_ {
        self.coords.iter().copied().zip(self.drags.iter().copied())
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum Direction {
    Clockwise,
    CounterClockwise,
}
/*
to move in just +X: move A and B in the same direction (Clockwise)
to move in just +Y: A and B counterclockwise 

*/
pub struct CoreXY<'a, LStepper, RStepper, MagnetPin, LeftLimitPin, RightLimitPin>
where
    LStepper: StepperOps,
    RStepper: StepperOps,
    MagnetPin: Pin,
    LeftLimitPin: Pin,
    RightLimitPin: Pin,
{
    left: LStepper,
    right: RStepper,
    magnet: OutputPinDriver<'a, MagnetPin>,
    left_limit: InputPinDriver<'a, LeftLimitPin>,
    right_limit: InputPinDriver<'a, RightLimitPin>,
    timer: TimerDriver<'a>
}

impl<'a, LStepper, RStepper, MagnetPin, LeftLimitPin, RightLimitPin>
    CoreXY<'a, LStepper, RStepper, MagnetPin, LeftLimitPin, RightLimitPin>
where
    LStepper: StepperOps,
    RStepper: StepperOps,
    MagnetPin: Pin,
    LeftLimitPin: Pin,
    RightLimitPin: Pin,
{
    pub fn new(
        left: LStepper,
        right: RStepper,
        magnet: OutputPinDriver<'a, MagnetPin>,
        left_limit: InputPinDriver<'a, LeftLimitPin>,
        right_limit: InputPinDriver<'a, RightLimitPin>,
        mut timer: TimerDriver<'a>
    ) -> Self {
        timer.enable(true).unwrap();
        let mut core = Self {
            left,
            right,
            magnet,
            left_limit,
            right_limit,
            timer
        };
        core.set_magnet(false);
        core.home();
        core
    }

    fn set_magnet(&mut self, engage: bool) {
        if engage {
            self.magnet.set_high().ok();
        } else {
            self.magnet.set_low().ok();
        }
    }

    fn goto(&mut self, square: u32) {
        let left_steps = self.left.position() as f32;
        let right_steps = self.right.position() as f32;
        let left_mm = (left_steps + right_steps) / (2.0 * DEFAULT_STEPS_PER_MM as f32);
        let right_mm = (left_steps - right_steps) / (2.0 * DEFAULT_STEPS_PER_MM as f32);

        let target_x_mm = ((square / 8) as f32 + 0.5) * SQUARE_SIZE_MM;
        let target_y_mm = ((square % 8) as f32 + 0.5) * SQUARE_SIZE_MM;

        let dx_mm = target_x_mm - left_mm; 
        let dy_mm = target_y_mm - right_mm;

        let delta_a_steps = (dx_mm + dy_mm) * DEFAULT_STEPS_PER_MM as f32;
        let delta_b_steps = (dx_mm - dy_mm) * DEFAULT_STEPS_PER_MM as f32;

        let mut steps_a = delta_a_steps.round() as i32;
        let mut steps_b = delta_b_steps.round() as i32;

        let dir_a = if steps_a >= 0 { Direction::Clockwise } else { Direction::CounterClockwise };
        let dir_b = if steps_b >= 0 { Direction::Clockwise } else { Direction::CounterClockwise };

        steps_a = steps_a.abs(); steps_b = steps_b.abs();

        self.left.set_direction(dir_a); self.right.set_direction(dir_b);

        let total = steps_a.max(steps_b).max(1); 
        let mut acc_a = 0; 
        let mut acc_b = 0; 

        let tick_hz = self.timer.tick_hz();
        let ticks_per_step = tick_hz / 2000 as u64; // todo! tune this

        for _ in 0..total {
            acc_a += steps_a; 
            acc_b += steps_b; 
            
            if acc_a >= total {
                self.left.step_once();
                acc_a -= total;
            }
            if acc_b >= total {
                self.right.step_once();
                acc_b -= total;
            }
            
            esp_idf_svc::hal::task::block_on(self.timer.delay(ticks_per_step)).unwrap();
        }
    }

    pub fn consume_instructions(&mut self, instructions: MoveInstruction) {
        for (sq, magnet) in instructions.iter() {
            self.goto(sq as u32);
            self.set_magnet(magnet);
        }
    }

    pub fn home(&mut self) {
        /*
        this might be offset from the actual center of the 0th square.
        might need to add some steps manually after the limit switch is hit
        */
        // home one axis at a time
        // todo: set individual tasks to run these to completion, on a hardware timer
        loop {
            let left = match self.left_limit.get_level() {
                Level::High => true,
                Level::Low => false,
            };
            if left {
                break;
            }
            self.left.steps(100);
            self.right.steps(100);
        }
        loop {
            let right = match self.right_limit.get_level() {
                Level::High => true,
                Level::Low => false,
            };
            if right {
                break;
            }
            self.left.steps(100);
            self.right.steps(100);
        }

        self.left.reset_position();
        self.right.reset_position();
    }
}

pub trait StepperOps {
    fn enable(&mut self);
    fn disable(&mut self);
    fn set_direction(&mut self, direction: Direction);
    fn step_once(&mut self);
    fn position(&self) -> u32;
    fn reset_position(&mut self);
    fn steps(&mut self, steps: i32);
}


pub struct Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    pos: u32,
    step: OutputPinDriver<'a, StepPin>,
    dir: OutputPinDriver<'a, DirPin>,
    en: OutputPinDriver<'a, EnPin>,
    current_direction: Direction,
}

impl<'a, StepPin, DirPin, EnPin> Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    pub fn new(
        step: OutputPinDriver<'a, StepPin>,
        dir: OutputPinDriver<'a, DirPin>,
        en: OutputPinDriver<'a, EnPin>,
    ) -> Self {
        let mut stepper= Stepper {
            pos: 0,
            step, 
            dir,
            en,
            current_direction: Direction::Clockwise,
        };
        // todo: verify direction
        stepper.set_direction(Direction::Clockwise);

        stepper 
    }
}

impl<'a, StepPin, DirPin, EnPin> StepperOps for Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    // todo! these are probably switched
    fn enable(&mut self) {
        self.en.set_low().ok();
    }

    fn disable(&mut self) {
        self.en.set_high().ok();
    }

    fn set_direction(&mut self, direction: Direction) {
        match direction {
            Direction::Clockwise => { self.dir.set_high().ok(); self.current_direction = Direction::Clockwise },
            Direction::CounterClockwise => { self.dir.set_low().ok(); self.current_direction = Direction::CounterClockwise },
        };
    }

    fn step_once(&mut self) {
        self.step.set_high().ok();
        self.step.set_low().ok();

        if self.current_direction == Direction::Clockwise {
            self.pos = self.pos.saturating_add(1);
        } else {
            self.pos = self.pos.saturating_sub(1);
        }
    }

    fn position(&self) -> u32 {
        self.pos
    }

    fn reset_position(&mut self) {
        self.pos = 0;
    }

    fn steps(&mut self, steps: i32) {
        // todo: create hardware timer based task here that moves stepper
        // should not be blocking, as in two steppers can move at the same time
        self.set_direction( if steps > 0 {
            Direction::Clockwise
        } else { 
            Direction::CounterClockwise 
        });
        let count = steps.unsigned_abs();
        let mut delay = Delay::new_default();

        for _ in 0..count {
            self.step_once();
            delay.delay_us(500);
        }
    }
}
