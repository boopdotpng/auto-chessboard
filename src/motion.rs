use esp_idf_svc::hal::gpio::{Level, Output, OutputPin, Pin, PinDriver};
use esp_idf_svc::timer::{EspTimer, EspTimerService};
use std::sync::{Arc, Mutex};
use std::time::Duration;

type OutputPinDriver<'a, Pin> = PinDriver<'a, Pin, Output>;

pub trait StepperDriver {
    fn enable(&
}

pub struct MoveInstruction {
    /* 
    an ordered list of squares to go to
    when to "drag", i.e. turn on the electromagnet
    the engine will generate these, becuase it knows where the pieces are and if it has to move more than the target piece around, like if a pawn needs to move for the knight needs to jump . 
    all moves will be straight up/down/left/right, no diagonal. 
    effectively time-based
    this is exclusively generated by the engine, not a event on the bluetooth evt bus 
     */
    coords: Vec<u8>, // 0-64 top left to bottom right 
    drags: Vec<bool>, // when to turn on the magnet (actually move a piece)
}

impl MoveInstruction {
    pub fn new(coords: Vec<u8>, drags: Vec<bool>) -> Self {
        assert_eq!(coords.len(), drags.len());
        Self { coords, drags }
    }

    pub fn iter(&self) -> impl Iterator<Item = (&u8, &bool)> + '_ {
        self.coords
        .iter()
        .zip(self.drags.iter())
    }
}


#[derive(Clone, Copy, PartialEq, Eq)]
enum Direction {
    Clockwise,
    CounterClockwise
}

// unify the control of two steppers in a corexy system
/* 
input will always be a list of operations to perform.
*/
const TICK_US: u64 = 50; // todo: tune this later
pub struct CoreXY<'a, Lstep, Ldir, Len, Rstep, Rdir, Ren>
where 
    Lstep: Pin,
    Ldir: Pin,
    Len: Pin,
    Rstep: Pin,
    Rdir: Pin,
    Ren: Pin
{
    l: Stepper<'a, Lstep, Ldir, Len>,
    r: Stepper<'a, Rstep, Rdir, Ren>,
}


// eventually this will be private. you just pass pins into CoreXY and it builds two Steppers
pub struct Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin:Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    pos: i32, 
    step: OutputPinDriver<'a, StepPin>,
    dir: OutputPinDriver<'a, DirPin>,
    en: OutputPinDriver<'a, EnPin>,
}

impl<'a, StepPin, DirPin, EnPin> Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    pub fn new(
        step: OutputPinDriver<'a, StepPin>,
        dir: OutputPinDriver<'a, DirPin>,
        en: OutputPinDriver<'a, EnPin>,
    ) -> Self {
        Self {
            pos: 0, step, dir, en
        }
    }

    pub fn enable(&mut self) { self.en.set_low().ok(); }
    pub fn disable(&mut self) { self.en.set_high().ok(); }

    pub fn set_direction(&mut self, direction: Direction) {
        let level = match direction {
            Direction::Clockwise => Level::High,
            Direction::CounterClockwise => Level::Low
        };
        self.dir.set_level(level).ok();
    }

    pub fn step_once(&mut self, direction: Direction) {
        self.set_direction(direction);
        self.step.set_high().ok();
        self.step.set_low().ok();

        self.pos += if direction == Direction::Clockwise { 1 } else { -1 };
    }

    pub fn pos(&self) -> i32 { self.pos }
}
