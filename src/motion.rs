use esp_idf_svc::hal::gpio::{Level, Output, OutputPin, Pin, PinDriver};
use esp_idf_svc::hal::timer::TimerDriver;
use core::time::Duration;

type OutputPinDriver<'a, Pin> = PinDriver<'a, Pin, Output>;

pub struct MoveInstruction {
    /* 
    an ordered list of squares to go to
    when to "drag", i.e. turn on the electromagnet
    the engine will generate these, becuase it knows where the pieces are and if it has to move more than the target piece around, like if a pawn needs to move for the knight needs to jump . 
    all moves will be straight up/down/left/right, no diagonal. 
    effectively time-based
    this is exclusively generated by the engine, not a event on the bluetooth evt bus 
     */
    coords: Vec<u8>, // 0-64 top left to bottom right 
    drags: Vec<bool>, // when to turn on the magnet (actually move a piece)
}

impl MoveInstruction {
    pub fn new(coords: Vec<u8>, drags: Vec<bool>) -> Self {
        Self { coords, drags }
    }

    pub fn iter(&self) -> impl Iterator<Item = (&u8, &bool)> + '_ {
        self.coords.iter().zip(self.drags.iter())
    }
}


#[derive(PartialEq, Eq)]
enum Direction {
    Clockwise,
    CounterClockwise
}

// unify the control of two steppers in a corexy system
/* 
input will always be a list of operations to perform.
*/
// pub struct CoreXY {
//     m1: Stepper,
//     m2: Stepper,
// }


// eventually this will be private. you just pass pins into CoreXY and it builds two Steppers
pub struct Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: Pin,
    DirPin: Pin,
    EnPin: Pin,
{
    pos: u32,
    step: OutputPinDriver<'a, StepPin>,
    dir: OutputPinDriver<'a, DirPin>,
    en: OutputPinDriver<'a, EnPin>,
}

impl<'a, StepPin, DirPin, EnPin> Stepper<'a, StepPin, DirPin, EnPin>
where
    StepPin: OutputPin + Pin,
    DirPin: OutputPin + Pin,
    EnPin: OutputPin + Pin,
{
    pub fn new(
        step: OutputPinDriver<'a, StepPin>,
        dir: OutputPinDriver<'a, DirPin>,
        en: OutputPinDriver<'a, EnPin>,
    ) -> Self {
        Self {
            pos: 0, step, dir, en
        }
    }

    pub fn move_blocking(&mut self, timer: &mut TimerDriver<'_>, steps: u32, freq_hz: u32, direction: Direction) {
        // todo: verify direction actually works this way
        self.dir.set_level(if direction == Direction::Clockwise {Level::High} else {Level::Low}).unwrap();

        // todo: is enable low or high when moving? 
        self.en.set_low().unwrap();
        
        let period_us = 1_000_000u32 / freq_hz; 
        let half = Duration::from_micros((period_us/2) as u64);

        for _ in 0..steps {
            self.step.set_high().ok();
            timer.delay(half).ok();

            self.step.set_low().ok();
            timer.delay(half).ok();

            match direction {
                Direction::Clockwise => self.pos+=1,
                Direction::CounterClockwise => self.pos-=1,
            }
        }
        self.en.set_high().ok();
    }
    pub fn home(&mut self) {}
}
